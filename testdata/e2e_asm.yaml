# End-to-end tests for C to ARM64 assembly generation
# These tests verify the full compilation pipeline from C source to assembly output

tests:
  - name: "hello world - return zero"
    input: |
      int main() { return 0; }
    expect:
      - ".text"
      - ".global\tmain"
      - "main:"
      - "ret"

  - name: "return constant"
    input: |
      int f() { return 42; }
    expect:
      - ".global\tf"
      - "f:"
      - "ret"

  - name: "function with parameters"
    input: |
      int add(int a, int b) { return a + b; }
    expect:
      - ".global\tadd"
      - "add:"
      - "add\t"
      - "ret"

  - name: "multiple functions"
    input: |
      int helper() { return 1; }
      int main() { return helper(); }
    expect:
      - ".global\thelper"
      - ".global\tmain"
      - "helper:"
      - "main:"
      - "bl\thelper"  # direct call to function symbol

  - name: "local variable"
    input: |
      int f() { int x = 5; return x; }
    expect:
      - ".global\tf"
      - "f:"
      - "ret"

  - name: "if statement"
    input: |
      int f(int x) { if (x) return 1; return 0; }
    expect:
      - ".global\tf"
      - "f:"
      - "b."  # conditional branch
      - "ret"

  - name: "while loop"
    input: |
      int f(int n) { int s = 0; while (n > 0) { s = s + n; n = n - 1; } return s; }
    expect:
      - ".global\tf"
      - "f:"
      - "b."  # conditional branch
      - "add\t"
      - "sub\t"
      - "ret"

  - name: "arithmetic operations"
    input: |
      int f(int a, int b) { return a * b + a - b; }
    expect:
      - ".global\tf"
      - "f:"
      - "mul\t"
      - "add\t"
      - "sub\t"
      - "ret"

  - name: "bitwise operations"
    input: |
      int f(int a, int b) { return (a & b) | (a ^ b); }
    expect:
      - ".global\tf"
      - "f:"
      - "and\t"
      - "orr\t"
      - "eor\t"
      - "ret"

  - name: "simple comparison"
    input: |
      int f(int a, int b) { if (a < b) return 1; return 0; }
    expect:
      - ".global\tf"
      - "f:"
      - "b."  # conditional branch based on comparison
      - "ret"

  - name: "shift right"
    input: |
      int f(int x) { return x >> 1; }
    expect:
      - ".global\tf"
      - "f:"
      - "asr\t"  # arithmetic shift right
      - "ret"

  # Test cases for known issues (docs/RUNNING.md)
  
  - name: "return value before ret - known issue 1"
    # Issue: return value must be set before ret instruction, not after
    input: |
      int main() { return 42; }
    expect:
      - ".global\tmain"
      - "main:"
      - "mov\tw0, #42"  # must set return value
      - "ret"
    expect_order:
      - "mov\tw0, #42"  # return value MUST come before ret
      - "ret"

  - name: "stack frame setup - known issue 2"
    # Issue: prologue must save FP/LR properly before modifying them
    input: |
      int f() { return 1; }
    expect:
      - ".global\tf"
      - "f:"
      - "stp\tx29, x30"  # must save FP and LR with stp
      - "ret"

  - name: "no duplicate functions - known issue 3"
    # Issue: each function should appear exactly once
    input: |
      int main() { return 0; }
    expect:
      - ".global\tmain"
      - "main:"
    expect_unique:
      - "main:"  # should appear exactly once

  - name: "unique labels across functions - known issue 4"
    # Issue: labels must be function-scoped to avoid collisions
    input: |
      int foo(int x) { if (x) return 1; return 0; }
      int bar(int x) { if (x) return 2; return 0; }
    expect:
      - ".global\tfoo"
      - ".global\tbar"
      - "foo:"
      - "bar:"
      - ".L_foo_"  # foo's labels should have foo prefix
      - ".L_bar_"  # bar's labels should have bar prefix
    expect_not:
      - ".L1:"     # plain .L1 without function prefix should not exist
      - ".L2:"     # plain .L2 without function prefix should not exist

  - name: "string literal in rodata section"
    # String literals should be emitted in .rodata section
    input: |
      int main() { char* msg = "hello"; return 0; }
    expect:
      - ".section\t.rodata"   # read-only data section for strings
      - ".Lstr0:"             # string label
      - ".byte\t104"          # 'h' = 104
      - ".byte\t101"          # 'e' = 101
      - ".byte\t108"          # 'l' = 108
      - ".byte\t111"          # 'o' = 111
      - ".byte\t0"            # null terminator
      - "adrp"                # address page calculation
      - ".text"               # code section after rodata
      - ".global\tmain"       # function definition
    expect_not:
      - ".global\t.Lstr0"     # local string labels should NOT be global

  - name: "multiple string literals"
    # Multiple strings should get unique labels
    input: |
      int main() {
        char* a = "foo";
        char* b = "bar";
        return 0;
      }
    expect:
      - ".section\t.rodata"
      - ".Lstr0:"             # first string
      - ".Lstr1:"             # second string
      - ".text"
      - ".global\tmain"
