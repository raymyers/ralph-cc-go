# Running Compiled Programs

This document describes how to run ARM64 assembly generated by ralph-cc.

## Architecture

ralph-cc generates **ARM64** (AArch64) assembly, targeting the ARM64 instruction set. This is the same architecture as Apple Silicon (M1/M2/M3/M4) Macs.

## Platform Support

### macOS on Apple Silicon (Native)

ARM64 assembly can be run **natively** on Apple Silicon Macs. However, ralph-cc outputs assembly in Linux/ELF format, which requires conversion to macOS/Mach-O format.

**Key differences between Linux and macOS ARM64 assembly:**

| Feature | Linux (ELF) | macOS (Mach-O) |
|---------|-------------|----------------|
| Symbol prefix | None | Underscore (`_main`) |
| `.type` directive | Supported | Not supported |
| `.size` directive | Supported | Not supported |
| Linker | `ld` with `-lc` | `ld` with `-lSystem` |

### Running via Script

A convenience script is provided:

```bash
./scripts/run.sh <input.c>
```

This script:
1. Compiles C source to ARM64 assembly using ralph-cc
2. Converts ELF-style assembly to macOS format
3. Assembles with the native `as` assembler
4. Links with `ld` against system libraries
5. Runs the executable

### Manual Steps

```bash
# 1. Generate assembly
./bin/ralph-cc -dasm input.c

# 2. Convert to macOS format
perl -pe '
    s/^\s*\.type.*//;
    s/^\s*\.size.*//;
    s/\.global\s+([a-zA-Z_][a-zA-Z0-9_]*)/.global _\1/;
    s/^([a-zA-Z_][a-zA-Z0-9_]*):/_\1:/;
    s/\bbl\s+([a-zA-Z_][a-zA-Z0-9_]*)/bl _\1/;
' input.s > input_macos.s

# 3. Assemble
as -o input.o input_macos.s

# 4. Link
ld -o input input.o -lSystem -L$(xcrun --show-sdk-path)/usr/lib

# 5. Run
./input
echo "Exit code: $?"
```

### Linux on ARM64 (Raspberry Pi, AWS Graviton, etc.)

On native ARM64 Linux, the assembly should work directly without conversion:

```bash
./bin/ralph-cc -dasm input.c
as -o input.o input.s
gcc -o input input.o
./input
```

### Cross-Platform via Docker/QEMU

To run ARM64 code on non-ARM64 hosts (e.g., AMD64 Linux/Mac), you can use:

1. **Docker with QEMU emulation:**
   ```bash
   docker run --rm --platform linux/arm64 -v $(pwd):/work -w /work \
       arm64v8/gcc:latest \
       sh -c "as -o input.o input.s && gcc -o input input.o && ./input"
   ```

2. **QEMU user-mode emulation:**
   ```bash
   # On Debian/Ubuntu with qemu-user installed
   aarch64-linux-gnu-as -o input.o input.s
   aarch64-linux-gnu-gcc -o input input.o -static
   qemu-aarch64 ./input
   ```

## Current Status

### What Works

- Assembly generation for simple functions
- Assembly/link/run pipeline on macOS Apple Silicon
- Basic instruction encoding (arithmetic, branches, memory access)
- Proper ARM64 prologue/epilogue using stp/ldp instructions
- Correct return value handling

### Test Results

```
$ echo 'int main() { return 42; }' > /tmp/test.c
$ ./scripts/run.sh /tmp/test.c
==> Compiling /tmp/test.c to ARM64 assembly...
==> Converting to macOS format...
==> Assembling...
==> Linking...
==> Running /tmp/test...
---
Exit code: 42   # Correct!
```

The program assembles, links, and runs correctly on Apple Silicon.

### Assembly Example

For `int main() { return 42; }`, ralph-cc generates:
```asm
main:
    stp     x29, x30, [sp, #-16]!   ; save FP and LR, pre-decrement SP
    mov     x29, sp                  ; set frame pointer
.L1:
    mov     w0, #42                  ; set return value
    ldp     x29, x30, [sp], #16     ; restore FP and LR, post-increment SP
    ret
```

### Hello World with stdio.h

```
$ ./scripts/run.sh testdata/example-c/hello.c
==> Compiling testdata/example-c/hello.c to ARM64 assembly...
==> Converting to macOS format...
==> Assembling...
==> Linking...
==> Running testdata/example-c/hello...
---
Hello, World!
---
Exit code: 0
```

The program correctly includes `<stdio.h>`, calls `printf`, and runs successfully.

## Known Limitations

- Only tested with simple programs (arithmetic, basic control flow, function calls)
- Structs and arrays are partially supported but may have issues
- No floating-point support tested
